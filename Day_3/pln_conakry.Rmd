---
title: "Glossina palpalis - PLNmodels - Networks"
date: "`r Sys.Date()`"
author: "Vincent Manzanilla" 
output: 
  rmdformats::material:
    code_folding: show
    use_bookdown: true
    thumbnails: false
    number_sections: true
    css: "ETBII.css"
header-includes:
  - \usepackage{subfig}
  - \usepackage{booktabs}
  - \usepackage{xcolor}
editor_options: 
  markdown: 
    wrap: 150
---

```{=html}
<style>

.textbox {
  border: 1px solid #ccc;
  padding: 10px;
  background-color: #f5f5f5;
}

.highlight {
  background-color: yellow;
  font-weight: bold;
}
</style>
```

# PLN Modeling

<p align="center">
  <img src="img/logo.png" alt="Logo" />
</p>


# Import data, data mangling, scaling

::: textbox
```{r library, message = FALSE, warning = FALSE}
library("dplyr")
library("phyloseq")
library("SNFtool")
library("pheatmap")
library("igraph")
library("tibble")
library("RCy3")
library("igraph")
library(microbiome)
library(arcdiagram)
library(MetaNet)
library(PLNmodels)
library(ggplot2)
library(future)
library(factoextra)
library(tidyr)
plan(multisession, workers = 15)
```
:::

# Import Data 

## loading 

```{r data}
merged_metagenomes <- phyloseq::import_biom("../data/fastq/kraken/bracken//merge_species.biom")
meta <- readxl::read_excel("../data/Glossina_metadata.xlsx")

# Set the new column names in the phyloseq object
sample_names(merged_metagenomes) <- gsub("_.*$|\\.kraken_report_bracken_genuses$", "", sample_names(merged_metagenomes))
sample_names(merged_metagenomes) <- gsub("^Gl", "GI", sample_names(merged_metagenomes))
# Sort the 'meta' data frame by the 'SRA.identifier' column
meta$Sample <- gsub("_.*$", "", meta$Sample)
meta$Samples <- meta$Sample
meta <- meta %>% column_to_rownames(var = "Samples")

# meta$Sample == sample_names(merged_metagenomes)

# Associate the sorted metadata to the phyloseq object as sample data
merged_metagenomes@sam_data <- sample_data(meta)

# Remove the unnecessary 'k_' prefix in the taxonomy data
merged_metagenomes@tax_table@.Data <- substring(merged_metagenomes@tax_table@.Data, 4)

# Rename the columns of the taxonomy table to represent taxonomic ranks
colnames(merged_metagenomes@tax_table@.Data) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")

#Keep only the kingdom of interest
merged_metagenomes <- subset_taxa(merged_metagenomes, Kingdom =="Bacteria")
# head(sample_data(merged_metagenomes))
# head(tax_table(merged_metagenomes))

# Define the list of samples to remove
samples_to_remove <- c("GI-103", "GI-59", "GI-104", "GI-111", "GI-121", 
                       "GI-124", "GI-125", "GI-14", "GI-15", "GI-16", 
                       "GI-17", "GI-25", "GI-26", "GI-27", "GI-28", 
                       "GI-29", "GI-30", "GI-31", "GI-32", "GI-33", 
                       "GI-34", "GI-36", "GI-38", "GI-39", "GI-45", "GI-47", "GI-51", "I9", "I7")

# Prune these samples from your phyloseq object
merged_metagenomes <- prune_samples(!(sample_names(merged_metagenomes) %in% samples_to_remove), merged_metagenomes)


physeq <- microbiome::aggregate_rare(merged_metagenomes, level = "Genus", detection = 0.01/100, prevalence = 5/100)
```

### sanity check

```{r, eval=FALSE}
# Identify OTUs with zero counts
empty_otus <- taxa_names(physeq)[taxa_sums(physeq) == 0]

# Print the empty OTU names
if (length(empty_otus) > 0) {
  print(paste("Empty OTUs:", paste(empty_otus, collapse = ", ")))
} else {
  print("No empty OTUs.")
}

# Identify samples with zero counts
empty_samples <- sample_names(physeq)[sample_sums(physeq) == 0]

# Print the empty sample names
if (length(empty_samples) > 0) {
    print(paste("Empty samples:", paste(empty_samples, collapse = ", ")))
} else {
    print("No empty samples.")
}

# # Remove samples with no counts
# physeq_F <- prune_samples(sample_sums(physeq) > 0, physeq)
# # Remove OTUs with no counts
# physeq_F <- prune_taxa(taxa_sums(physeq) > 0, physeq)
```

```{r}
tax_table_df <- as.data.frame(physeq@tax_table)
otus_to_keep <- rownames(tax_table_df[tax_table_df$Genus != "Other", ])
physeq <- prune_taxa(otus_to_keep, physeq)
```

## Variable used for the analysis 

```{r}
# Phyloseq object
physeq <- microbiome::aggregate_taxa(physeq, level = "Genus")
# Count data
counts <- otu_table(physeq) %>% as.data.frame() %>% t()
meta <- physeq@sam_data
```

## Create Female and Male dataset 

```{r, cache=TRUE}

# Subset phyloseq object for female samples
physeq_F <- subset_samples(physeq, sex == "F")
samples_to_remove <- c("GI-45", "GI-51")
physeq_F <- prune_samples(!(sample_names(physeq_F) %in% samples_to_remove), physeq_F)
# Remove samples with no counts
physeq_F <- prune_samples(sample_sums(physeq_F) > 0, physeq_F)
# Remove OTUs with no counts
physeq_F <- prune_taxa(taxa_sums(physeq_F) > 0, physeq_F)
data_F <- prepare_data(counts = physeq_F@otu_table, covariates = physeq_F@sam_data, offset = "Wrench")


# Subset phyloseq object for female samples
physeq_M <- subset_samples(physeq, sex == "M")
physeq_M <- prune_samples(!(sample_names(physeq_M) %in% samples_to_remove), physeq_M)
data_M <- prepare_data(counts = physeq_M@otu_table, covariates = physeq_M@sam_data, offset = "Wrench")
```

### Sanity check

```{r }
# Identify OTUs with zero counts
empty_otus <- taxa_names(physeq_F)[taxa_sums(physeq_F) == 0]

# Print the empty OTU names
if (length(empty_otus) > 0) {
    print(paste("Empty OTUs:", paste(empty_otus, collapse = ", ")))
} else {
    print("physeq_F: No empty OTUs.")
}

# Identify samples with zero counts
empty_samples <- sample_names(physeq_F)[sample_sums(physeq_F) == 0]

# Print the empty sample names
if (length(empty_samples) > 0) {
    print(paste("Empty samples:", paste(empty_samples, collapse = ", ")))
} else {
    print("physeq_F: No empty samples.")
}

# # Remove samples with no counts
# physeq_F <- prune_samples(sample_sums(physeq_F) > 0, physeq)
# # Remove OTUs with no counts
# physeq_F <- prune_taxa(taxa_sums(physeq_F) > 0, physeq)

# Identify OTUs with zero counts
empty_otus <- taxa_names(physeq_F)[taxa_sums(physeq_M) == 0]

# Print the empty OTU names
if (length(empty_otus) > 0) {
    print(paste("Empty OTUs:", paste(empty_otus, collapse = ", ")))
} else {
    print("physeq_M: No empty OTUs.")
}

# Identify samples with zero counts
empty_samples <- sample_names(physeq_F)[sample_sums(physeq_M) == 0]

# Print the empty sample names
if (length(empty_samples) > 0) {
    print(paste("Empty samples:", paste(empty_samples, collapse = ", ")))
} else {
    print("physeq_M: No empty samples.")
}
```

# Check the distribution of the data 

We have a clear Poisson distribution.


```{r, cache=TRUE, fig.show = "hold", fig.align = "center", out.width = "50%"}
hist(as.matrix(as.data.frame(physeq@otu_table), nclass = 10, main = "Abundance of the OTU data", xlab = "values"))
```


# Male and female combined through time
## Poisson lognormal models

The Poisson lognormal model is a statistical model used to describe count data that exhibits overdispersion, which means the variance is greater than
the mean. This model combines two components: a Poisson distribution and a lognormal distribution.

By combining the Poisson and lognormal distributions, this model provides a flexible approach to modeling count data that exhibit greater variability
than what can be captured by a simple Poisson distribution alone.

### Create a PNL suited data frame.

```{r, cache=TRUE}
# data PLN object
PLN_data <- PLNmodels::prepare_data(counts = counts, covariates = meta)
```

### Setting up the GLM model

**Intercept (\~1):** - There is a common baseline level of abundance for taxa in the microbiome samples, and zero abundance represents a biological
state (not a data artifact), then Abundance \~ 1 + offset(log(Offset)) is appropriate. The intercept allows to model this baseline. - Implicitly
assume that all taxa have some baseline level of abundance, even if some taxa may have zero abundance in certain samples. Whith this model, we are
looking at how each taxon's abundance varies around this assumed baseline level.

**No Intercept (\~0):** - Zero abundance represents the true absence of a taxon and there isn’t a common baseline abundance that all taxa share, then
Abundance \~ 0 + offset(log(Offset)) might be more appropriate. This formulation explicitly models the starting point as zero. - **Baseline Level:**
This refers to a hypothetical or observed starting point or average level of abundance across all taxa in your microbiome samples. It represents a
point of comparison against which you assess changes or differences. - This approach is useful when zero abundance values (where taxa are absent) are
not due to technical limitations but rather reflect genuine biological absence. It allows to interpret changes in abundance levels in relation to what
you consider to be the typical or expected level of abundance for each taxon.

**Offset (offset(log(Offset))):** - **Purpose:** The offset term adjusts for differences in exposure or scaling factors that are known and fixed for
each observation - **Example:** In microbiome studies, offsets are often used to account for differences in sequencing depth or sampling effort across
samples. The logarithm transformation (log(Offset)) is common to handle the typical skewness in abundance data.

We can test both models (\~1 and \~0) and evaluate their goodness of fit metrics (like AIC or BIC) to determine which one better captures the
variability in our data.

```{r, cache=TRUE}
Model_01_0 <- PLN(PLN_data$Abundance ~ 0 + offset(log(Offset)), PLN_data)
Model_02_1 <- PLN(PLN_data$Abundance ~ 1 + offset(log(Offset)), PLN_data)
```

```{r, cache=TRUE}
rbind(
  "No Intercept" = Model_01_0$criteria,
  "With Intercept" = Model_02_1$criteria
) %>% knitr::kable()
```

- **Log-likelihood (loglik)**: A higher value indicates a better fit to the data.
- **Bayesian Information Criterion (BIC)**: A lower value indicates a better model, balancing model fit and complexity.
- **Integrated Complete Likelihood (ICL)**: Similar to BIC, a lower ICL value is preferred, with additional penalization for the complexity of the model.

**With Intercept** (`PLN(PLN_data$Abundance ~ 1 + offset(log(Offset)), PLN_data)`) appears to be the better model choice among the two based on
the given criteria.

## Model evaluation

```{r, cache=TRUE}
Model_01 <- PLN(PLN_data$Abundance ~ 1, PLN_data)
```

```{r, cache=TRUE}
Model_02 <- PLN(PLN_data$Abundance ~ 1 + offset(log(Offset)), PLN_data)
```

```{r, cache=TRUE}
Model_03 <- PLN(PLN_data$Abundance ~ 1 + sex + offset(log(Offset)), PLN_data)
```

```{r, cache=TRUE}
Model_04 <- PLN(PLN_data$Abundance ~ 1 + Ecological.gradient + offset(log(Offset)), PLN_data)
```

```{r, cache=TRUE}
Model_05 <- PLN(PLN_data$Abundance ~ 1 + Caracteristic.Gradient + offset(log(Offset)), PLN_data)
```

```{r, cache=TRUE}
Model_06 <- PLN(PLN_data$Abundance ~ 1 + infection + offset(log(Offset)), PLN_data)
```

```{r, cache=TRUE}
results <- rbind(
  "PLN_data" = Model_01$criteria,
  "PLN_data Offset" = Model_02$criteria,
  "PLN_data sex" = Model_03$criteria,
  "PLN_data Ecological gradient" = Model_04$criteria,
  "PLN_data Caracteristic Gradient" = Model_05$criteria,
  "PLN_data Infection" = Model_06$criteria
)

print(results) %>%
  arrange(loglik) %>%
  knitr::kable()
```

Selected **PLN_data Ecological gradient**.

### GLM-like interface

One can access the fitted value of the counts (Abundance – Y\^) and check that the algorithm basically learned correctly from the data:

```{r, cache=TRUE}
data.frame(
  fitted   = as.vector(fitted(Model_06)),
  observed = as.vector(PLN_data$Abundance)
) %>%
  ggplot(aes(x = observed, y = fitted)) +
  geom_point(size = .5, alpha = .25) +
  scale_x_log10() +
  scale_y_log10() +
  theme_bw() +
  annotation_logticks()
```

The residual correlation matrix better displays as an image matrix:

```{r, cache=TRUE}
Model_06 %>%
  sigma() %>%
  cov2cor() %>%
  corrplot::corrplot(, tl.cex = 0.4)
```

### Observation weights

```{r, cache=TRUE}
myPLN_weighted <-
  PLN(
    PLN_data$Abundance ~ 1 + Ecological.gradient + offset(log(Offset)),
    data    = PLN_data,
    weights = runif(nrow(PLN_data)),
    control = PLN_param(trace = 0)
  )
data.frame(
  unweighted = as.vector(fitted(Model_06)),
  weighted   = as.vector(fitted(myPLN_weighted))
) %>%
  ggplot(aes(x = unweighted, y = weighted)) +
  geom_point(size = .5, alpha = .25) +
  scale_x_log10(
    breaks = scales::trans_breaks("log10", function(x) 10^x),
    labels = scales::trans_format("log10", scales::math_format(10^.x))
  ) +
  scale_y_log10(
    breaks = scales::trans_breaks("log10", function(x) 10^x),
    labels = scales::trans_format("log10", scales::math_format(10^.x))
  ) +
  theme_bw() +
  annotation_logticks() +
  labs(x = "Unweighted Fitted Values", y = "Weighted Fitted Values")
```

**Effect of Small Weights**: Observations with very small weights might be receiving much less influence in the weighted model. If an observation has
a weight close to zero, its contribution to the fitted values will be minimal. This can lead to significant deviations between the unweighted and
weighted models, especially if the unweighted model provides a much larger fitted value for those observations.

**General Linear Trend**: Most observations align with a linear relationship, indicating that the weights are generally applied in a consistent manner
across the dataset. **Distinct Clouds**: The additional clouds suggest that specific subsets of data behave differently, either due to the extreme or
moderate influence of weights, unique characteristics of those observations, or potential data issues.

```{r, cache=TRUE}
PLN_data <- PLN_data %>% as.data.frame()
# Extract unweighted fitted values
a <- fitted(Model_06) %>% as.data.frame()
a <- a %>%
  mutate(Sample = rownames(PLN_data)) %>%
  column_to_rownames("Sample")
colnames(a) <- PLN_data$Abundance %>% colnames()

unweighted_df <- a %>%
  mutate(Ecological.gradient =  PLN_data$Ecological.gradient) %>%
  rownames_to_column("Sample") %>%
  pivot_longer(-c(Sample, Ecological.gradient), names_to = "Variable", values_to = "Unweighted")

# Extract weighted fitted values
b <- fitted(myPLN_weighted) %>% as.data.frame()
b <- b %>%
  mutate(Sample = rownames(PLN_data)) %>%
  column_to_rownames("Sample")
colnames(b) <- PLN_data$Abundance %>% colnames()

weighted_df <- b %>%
  mutate(Ecological.gradient = PLN_data$Ecological.gradient) %>%
  rownames_to_column("Sample") %>%
  pivot_longer(-c(Sample, Ecological.gradient), names_to = "Variable", values_to = "Weighted")

# Merge the unweighted and weighted data
merged_df <- unweighted_df %>%
  select(Sample, Variable, Unweighted) %>%
  dplyr::left_join(weighted_df, by = c("Sample", "Variable")) %>%
  select(Sample, Variable, Unweighted, Weighted, Ecological.gradient)

# Inspect the merged data frame
head(merged_df)


# Define your color palette
colors <- c(
  "wild" = "#009392",
  "ecotone" = "#9ccb86",
  "farmed land" = "#EEB479",
  "urban" = "#CF597E"
)

# Plot with transparency
ggplot(merged_df, aes(x = Unweighted, y = Weighted, color = Ecological.gradient)) +
  geom_point(size = 1, alpha = 0.4) + # Adjust alpha for transparency
  scale_x_log10() +
  scale_y_log10() +
  scale_color_manual(values = colors) +
  theme_bw() +
  labs(
    x = "Unweighted Fitted Value",
    y = "Weighted Fitted Value",
    color = "Ecological.gradient"
  ) +
  theme(legend.position = "bottom")
```

### Investigating the cloud with larger weights on the x axis

```{r, cache=TRUE}
results_df <- data.frame(
  unweighted = as.vector(fitted(Model_06)),
  weighted = as.vector(fitted(myPLN_weighted)),
  "Sample" = rownames(PLN_data) # Assuming sample IDs are rownames or add another identifier
)
# Filter the dataframe based on the conditions
filtered_samples <- merged_df %>% filter(Unweighted > 1e-5 & Weighted < 1e-4)

# Print the filtered samples
head(filtered_samples)
```

### Investigating the cloud top left corner.

```{r, cache=TRUE}
# Filter the dataframe based on the conditions
filtered_samples <- merged_df %>% filter(Unweighted < 1e-4 & Weighted > 1e-6)

# Print the filtered samples
head(filtered_samples)
```

## PCA

```{r ,cache=TRUE}
ticks_pca_clim <- PLNPCA(
  formula = PLN_data$Abundance ~ 1 +
    Ecological.gradient +
    offset(log(Offset)),
  data = PLN_data,
  ranks = 1:20
)
```

```{r, cache=TRUE}
plot(ticks_pca_clim)
```

```{r, cache=TRUE}
ticks_pca_clim_best <- getBestModel(ticks_pca_clim, crit = "ICL")
```

```{r, cache=TRUE}
plot(ticks_pca_clim_best, map = "individual", axes = 1:2, ind_cols = PLN_data$Ecological.gradient)
```

```{r, cache=TRUE}
sigma(ticks_pca_clim_best) %>%
  corrplot::corrplot(is.corr = FALSE, tl.cex = 0.5, col = corrplot::COL2("PiYG"), type = "lower", diag = T)
```

```{r, cache=TRUE}
# Define the threshold function
keep_high_correlations <- function(x) {
  any(x > 2 | x < -1)
}

########################### Climatic ##################
rows_to_keep <- apply(sigma(ticks_pca_clim_best), 1, keep_high_correlations)
cols_to_keep <- apply(sigma(ticks_pca_clim_best), 2, keep_high_correlations)

# Subset the matrix to keep only the selected rows and columns
ticks_pca_clim_best_filtered <- sigma(ticks_pca_clim_best)[rows_to_keep, cols_to_keep]

# Print the head of the filtered matrix to check
# head(oaks_best_pca_filtered)
ticks_pca_clim_best_filtered %>%
  corrplot::corrplot(is.corr = FALSE, tl.cex = 0.4, col = corrplot::COL2("PiYG"), type = "lower", diag = T)
```

```{r, cache=TRUE}
factoextra::fviz_pca_biplot(ticks_pca_clim_best,
  select.var = list(contrib = 10),
  labels = NULL,
  geom = "point"
) # CONTRIBUTION TOP 20 CLUSTER.
```


```{r, cache=TRUE}
fviz_pca_var(ticks_pca_clim_best,
  col.var = "contrib",
  gradient.cols = c("#00AFBB",
                    "#E7B800",
                    "#FC4E07"),
  select.var = list(contrib = 20)
)
```

```{r, cache=TRUE}
ticks_pca_clim_best$var %>%
  as.data.frame() %>%
  select(contrib.Dim.1, contrib.Dim.2) %>%
  arrange(contrib.Dim.1) %>%
  tail(n = 10) %>%
  knitr::kable()
```

```{r, cache=TRUE}
fviz_contrib(ticks_pca_clim_best, choice = "var", axes = 1:2, top = 10)
```

## Network

```{r, cache=TRUE}
networks_full <- PLNnetwork(formula = PLN_data$Abundance ~ 1 +
  Ecological.gradient +
  offset(log(Offset)), data = PLN_data)
```

### Assessment of the model

```{r, cache=TRUE}
networks_full$criteria %>%
  head() %>%
  knitr::kable()
```

A diagnostic of the optimization process is available via the \``convergence` field:

```{r, cache=TRUE}
networks_full$convergence %>%
  head() %>%
  knitr::kable()
```

**convergence:** This column shows the convergence tolerance or criterion. It represents how close the algorithm was to meeting the convergence criteria, with smaller values indicating closer adherence to the convergence criteria. Values close to zero (like the ones shown here) indicate that the models have converged successfully.

```{r, cache=TRUE}
plot(networks_full, "diagnostic")
```

### Exploring the path of networks

```{r, cache=TRUE}
plot(networks_full, reverse = TRUE)
```

```{r, cache=TRUE}
coefficient_path(networks_full, corr = TRUE) %>%
  ggplot(aes(x = Penalty, y = Coeff, group = Edge, colour = Edge)) +
  geom_line(show.legend = FALSE) +
  coord_trans(x = "log10") +
  theme_bw()
```

**How to Interpret:**

-   As the penalty increases (moves right on the x-axis), the regularization strength increases, typically leading to more coefficients shrinking
    towards zero.
-   Lines that stay above zero or deviate less from zero indicate more robust and significant relationships between variables, as these edges are less
    affected by regularization.
-   Lines that move towards zero quickly as the penalty increases indicate weaker relationships that are regularized out of the model early.

### Choosing a network

```{r, cache=TRUE}
model_StARS <- getBestModel(networks_full, "StARS")
plot(networks_full, "stability")
```

### Structure of a PLNnetworkfit

```{r, cache=TRUE}
model_StARS
```

We can finally check that the fitted value of the counts – even with sparse regularization of the covariance matrix – are close to the observed ones:

```{r, cache=TRUE}
data.frame(
  fitted   = as.vector(fitted(model_StARS)),
  observed = as.vector(PLN_data$Abundance)
) %>%
  ggplot(aes(x = observed, y = fitted)) +
  geom_point(size = .5, alpha = .25) +
  scale_x_log10(limits = c(1, 4000)) +
  scale_y_log10(limits = c(1, 4000)) +
  theme_bw() +
  annotation_logticks()
```

### Stability threashold = 0.9

```{r, cache=TRUE}
ticks_best_network_2 <- model_StARS
my_graph <- plot(ticks_best_network_2, plot = F)
Isolated <- which(igraph::degree(my_graph) == 0)
my_graph_cleaned <- delete_vertices(my_graph, Isolated)

my_graph <- my_graph_cleaned

vertices_names <- V(my_graph)$name

result <- merged_metagenomes@tax_table %>% 
  as.data.frame() %>%
  filter(Genus %in% vertices_names) %>%
  select(Genus, Family)

# Extract unique families
unique_families <- unique(result$Family)
# Generate distinct colors for each family
n_colors <- length(unique_families)
colors <- khroma::colour("smooth rainbow")(n_colors)
# Create a named vector to map each family to a color
family_colors <- setNames(colors, unique_families)
# Add the color information to the result dataframe
result <- result %>%
  mutate(Color = family_colors[Family])

# extract abundance OTU
otu_table_df <- as.data.frame(otu_table(physeq))
abundance <- otu_table_df %>%
  mutate(Abundance = rowSums(.)) %>%
  rownames_to_column("vertices_left")
abundance_solo <- abundance %>%
  as.data.frame() %>%
  filter(vertices_left %in% vertices_names) %>%
  select(Abundance)

# # Convert the Abundance column to a numeric vector
# vertex_sizes <- as.numeric(abundance_solo$Abundance)
# # Scale the vertex sizes for better visibility
# vertex_sizes <- (vertex_sizes / max(vertex_sizes)) * 10  # Adjust the multiplier as needed
# Assign colors to the vertices
V(my_graph)$color <- result$Color
# Assign sizes to the vertices
# V(my_graph)$size <- vertex_sizes
# Choose a layout that spreads out the vertices
layout <- igraph::layout_in_circle(my_graph)

# Define unique colors and families for the legend
unique_colors <- unique(result$Color)
unique_families <- unique(result$Family)

# Define edge width for the legend
edge_widths <- E(my_graph)$width
unique_edge_widths <- unique(edge_widths)

# Edge - Arc colors
weight <- as.numeric(E(my_graph)$weight)
color_palette <- colorRampPalette(c("yellow", "red"))(200)
normalized_weights <- (weight - min(weight)) / (max(weight) - min(weight))
edge_colors <- sapply(seq_along(normalized_weights), function(i) {
  if (i == 97) {
    "#009fff"
  } else {
    color_palette[as.integer(normalized_weights[i] * (length(color_palette) - 1)) + 1]
  }
})
edge_attr(my_graph)$color <- edge_colors

E(my_graph)$color <- edge_colors

plot(simplify(my_graph),
  layout = layout,
  vertex.size = (V(my_graph)$size) * 2,
  vertex.label.dist = 1,
  vertex.label.cex = 0.5,
  edge.width = E(my_graph)$width,
  edge.color = E(my_graph)$color,
  margin = 0.2,
  main = "Network based on the GLM ~ month + Offset by sex group",
  sub = "Stability threashold 0.20 - Verticles colored by families, Edges colored by weight",
  rescale = T
)
legend("left",
  legend = unique_families,
  col = unique_colors,
  pch = 19,
  title = "Families",
  pt.cex = 2,
  cex = 0.5,
  bty = "n",
  y.intersp = 0.6,
  inset = 1 / 10
)
```

```{r, cache=TRUE}
my_graph_metaN <- c_net_update(my_graph)

V(my_graph_metaN)$v_group <- result$Family
V(my_graph_metaN)$color <- V(my_graph)$color
V(my_graph_metaN)$size <- vertex_attr(my_graph)$size
V(my_graph_metaN)$v_class <- result$Family
E(my_graph_metaN)$color <- E(my_graph)$color

# Set the background color to black using par and text parameters
par(bg = "white", family = "serif", col.axis = "lightgrey", col.lab = "lightgrey", col.main = "lightgrey", col.sub = "lightgrey")

c_net_plot(my_graph_metaN,
           vertex.color = V(my_graph_metaN)$color, vertex.size = ((V(my_graph_metaN)$size)*2), 
           vertex.label.color = "black",vertex.label = V(my_graph_metaN)$name, vertex.label.cex = 0.5,
           edge_width_range = c(0.5, 3), edge.color = "green4", edge.curved = 0.4,
           legend = F, legend_number = F, 
           edge_legend_title = "Weight",
           size_legend = F, size_legend_title = "Abundance",
           width_legend = T, width_legend_title = "Weight"
           )
# vertex_attr(my_graph_metaN)
# vertex_attr(my_graph)
legend("right",
  legend = unique_families,
  col = unique_colors,
  # title = "Families",
  pch = 19,
  pt.cex = 2,
  cex = 0.6,
  text.font = 3,
  bty = "n",
  y.intersp = 0.4,
  inset = 6 / 10
)
legend_x <- 0.85
legend_y <- 0.9 
text(x = legend_x - 2.5, y = legend_x - 0.35, labels = "Families", pos = 1, cex = 0.8, font = 4)
# 
# # Define the thickness range
# min_thickness <- 0.5
# max_thickness <- 3
# 
# # Calculate the thickness for each weight
# thickness_values <- min_thickness + (max_thickness - min_thickness) * normalized_weights
# 
# # Create a unique set of thickness values for the legend
# unique_thickness <- unique(round(thickness_values,digits = 0))
# 
# # Generate labels for the thickness values
# thickness_labels <- round(unique_thickness, 2)
# 
# # Add the legend for the weights
# legend("right",
#        legend = thickness_labels,
#        col = "black",
#        lty = 1, # Line type
#        lwd = unique_thickness, # Line width corresponding to thickness
#        title = "Weights",
#        cex = 0.5, y.intersp = 0.5,
#        text.font = 3 # Italic text
# )
```

```{r, cache=TRUE}
V(my_graph_metaN)$v_class <- result$Family

c_net_plot(my_graph_metaN,  
           coors = g_layout_polygon(my_graph_metaN, group = "v_class")
           )
```

### Arc diagram

```{r, cache=TRUE}
## get edgelist
edgelist = as_edgelist(my_graph)

order_species <- c("Trueperella_1","Corynebacterium_6", "Fusobacterium_2","Corynebacterium_1", "Corynebacterium_3", "Corynebacterium_4", "Corynebacterium_8", 
                   "Streptococcus_1", "Peptoniphilus_1", "Mycobacterium_1", "Rhodococcus_1", "Multi-affiliation1_1", "Sphingomonas_1", 
                   "Francisella_10", "Francisella_6", "Francisella_9", "Williamsia_2", "Corynebacterium_5", "Multi-affiliation_1", "Corynebacterium_7",
                   "Halomonas_2", "Mycobacterium_2", "Williamsia_1", "Nocardioides_1",  "Francisella_8", "Xanthomonas_1", "Acinetobacter_2", 
                   "Staphylococcus_3", "Staphylococcus_4", "Acinetobacter_1", "Candidatus Midichloria_1", "Francisella_4", "Francisella_5", 
                   "Candidatus Midichloria_2", "Candidatus Midichloria_6", "Candidatus Midichloria_7") 

result <- result %>%  mutate(size = vertex_attr(my_graph)$size)
result_ordered <- result[match(order_species, result$Genus), ]

# Set the background color to black using par and text parameters
par(bg = "black", family = "serif", col.axis = "lightgrey", col.lab = "lightgrey", col.main = "lightgrey", col.sub = "lightgrey")
# plot arc diagram
arcplot(edgelist, 
        cex.labels = 0.7,
        sorted = FALSE,
        show.nodes = TRUE,
        bg.nodes = result_ordered$Color,
        cex.nodes = (result_ordered$size) * 0.8, 
        pch.nodes = 21, 
        lwd.nodes = 0.2, 
        line = 0,
        lwd.arcs = 20 * (edge_attr(my_graph)$weight),
        col.arcs = edge_attr(my_graph)$color,
        col.labels = "lightgrey", # Set font color for labels
        col.nodes = "black",  # Set font color for node labels
        bg = NA # Use NA to keep the par bg color
#        above = c(1:97,99:114)
)
legend("right",
       legend = unique_families,
       col = unique_colors,
       pch = 19,
       title = "Families",
       pt.cex = 2,
       cex = 0.7,
       text.font = 3, # Set font to Times New Roman (serif)
       text.col = "lightgrey", # Set font color to light grey
       bty = "n",
       y.intersp = 0.5
    #   inset = 1 / 10
)
```






# Female Data Set
## PCA

```{r, cache=TRUE}
PLN_pca_F <- PLNPCA(
  formula = data_F$Abundance ~ 1 +
    offset(log(Offset)),
  data = data_F,
  ranks = 1:20
)

```

```{r, cache=TRUE}
plot(PLN_pca_F)
```

```{r, cache=TRUE}
PLN_pca_F_best <- getBestModel(PLN_pca_F, crit = "BIC")
```

```{r, cache=TRUE}
plot(PLN_pca_F_best, map = "individual", axes = 1:2, ind_cols = data_F$Ecological.gradient)
```

```{r, cache=TRUE}
sigma(PLN_pca_F_best) %>%
  corrplot::corrplot(is.corr = FALSE, tl.cex = 0.5, col = corrplot::COL2("PiYG"), type = "lower", diag = T)

# Define the threshold function
keep_high_correlations <- function(x) {
  any(x > 2 | x < -1)
}

########################### Climatic ##################
rows_to_keep <- apply(sigma(PLN_pca_F_best), 1, keep_high_correlations)
cols_to_keep <- apply(sigma(PLN_pca_F_best), 2, keep_high_correlations)

# Subset the matrix to keep only the selected rows and columns
PLN_pca_F_best_filtered <- sigma(PLN_pca_F_best)[rows_to_keep, cols_to_keep]

# Print the head of the filtered matrix to check
# head(oaks_best_pca_filtered)
PLN_pca_F_best_filtered %>%
  corrplot::corrplot(is.corr = FALSE, tl.cex = 0.4, col = corrplot::COL2("PiYG"), type = "lower", diag = T)
```

```{r, cache=TRUE}
factoextra::fviz_pca_biplot(PLN_pca_F_best,
  select.var = list(contrib = 10),
  labels = NULL,
  geom = "point"
) # CONTRIBUTION TOP 20 CLUSTER.
```

```{r, cache=TRUE}
# Define your color palette
colors <- c(
  "wild" = "#009392",
  "ecotone" = "#9ccb86",
  "farmed land" = "#EEB479",
  "urban" = "#CF597E"
)

# Plot PCA with ordered legend
fviz_pca_ind(PLN_pca_F_best,
  col.ind = data_F$Ecological.gradient,
  palette = colors,
  geom.ind = "point",
  repel = TRUE,
  pointsize = 4,
  pointshape = 19,
  col.var = "black",
  arrowsize = 0.6,
  labelsize = 4
) +
  labs(color = "Ecological gradient") +
  scale_color_manual(values = colors) +
  guides(color = guide_legend(order = 1))
```

```{r, cache=TRUE}
fviz_pca_var(PLN_pca_F_best,
  col.var = "contrib",
  gradient.cols = c("#00AFBB",
                    "#E7B800",
                    "#FC4E07"),
  select.var = list(contrib = 20)
)
```

```{r, cache=TRUE}
PLN_pca_F_best$var %>%
  as.data.frame() %>%
  select(contrib.Dim.1, contrib.Dim.2) %>%
  arrange(contrib.Dim.1) %>%
  tail(n = 10) %>%
  knitr::kable()
```

```{r, cache=TRUE}
fviz_contrib(PLN_pca_F_best, choice = "var", axes = 1:2, top = 10)
```

## Network

### Modeling

```{r, cache=F}
networks_F <- PLNnetwork(formula = data_F$Abundance ~ 1 +
  Ecological.gradient  +
  offset(log(Offset)), data = data_F)

```

```{r, cache=TRUE}
plot(networks_F, "diagnostic")
```

```{r, cache=TRUE}
coefficient_path(networks_F, corr = TRUE) %>%
  ggplot(aes(x = Penalty, y = Coeff, group = Edge, colour = Edge)) +
  geom_line(show.legend = FALSE) +
  coord_trans(x = "log10") +
  theme_bw()
```

```{r, cache=TRUE}
model_StARS <- getBestModel(networks_F, "StARS")
```

```{r, cache=TRUE}
plot(networks_F, "stability")
```

```{r, cache=TRUE, warning=FALSE, eval=FALSE}
data.frame(
  fitted   = as.vector(fitted(model_StARS)),
  observed = as.vector(count_f2)
) %>%
  ggplot(aes(x = observed, y = fitted)) +
  geom_point(size = .5, alpha = .25) +
  scale_x_log10(limits = c(1, 4000)) +
  scale_y_log10(limits = c(1, 4000)) +
  theme_bw() +
  annotation_logticks()
```

## Visualisation

```{r, cache=T}

networks_F_2 <- getBestModel(networks_F, crit = "StARS", stability = 0.9)

my_graph <- plot(networks_F_2, plot = F)
Isolated <- which(igraph::degree(my_graph) == 0)
my_graph_cleaned <- igraph::delete_vertices(my_graph, Isolated)
# my_graph_cleaned <- delete_vertices(my_graph, c("Francisella_8", "Candidatus Midichloria_11"))

my_graph <- my_graph_cleaned

vertices_names <- V(my_graph)$name
taxo <- tax_table(physeq)

result <- merged_metagenomes@tax_table %>% 
  as.data.frame() %>%
  filter(Genus %in% vertices_names) %>%
  select(Genus, Family)

# Extract unique families
unique_families <- unique(result$Family)
# Generate distinct colors for each family
n_colors <- length(unique_families)
colors <- khroma::colour("smooth rainbow")(n_colors)
# Create a named vector to map each family to a color
family_colors <- setNames(colors, unique_families)
# Add the color information to the result dataframe
result <- result %>%
  mutate(Color = family_colors[Family])

# extract abundance OTU
otu_table_df <- as.data.frame(otu_table(physeq))
abundance <- otu_table_df %>%
  mutate(Abundance = rowSums(.)) %>%
  rownames_to_column("vertices_left")
abundance_solo <- abundance %>%
  as.data.frame() %>%
  filter(vertices_left %in% vertices_names) %>%
  select(Abundance)

# # Convert the Abundance column to a numeric vector
# vertex_sizes <- as.numeric(abundance_solo$Abundance)
# # Scale the vertex sizes for better visibility
# vertex_sizes <- (vertex_sizes / max(vertex_sizes)) * 10  # Adjust the multiplier as needed
# Assign colors to the vertices
V(my_graph)$color <- result$Color
# Assign sizes to the vertices
# V(my_graph)$size <- vertex_sizes
# Choose a layout that spreads out the vertices
layout <- igraph::layout_in_circle(my_graph)

# Define unique colors and families for the legend
unique_colors <- unique(result$Color)
unique_families <- unique(result$Family)

# Define edge width for the legend
edge_widths <- E(my_graph)$width
unique_edge_widths <- unique(edge_widths)

# Edge - Arc colors
weight <- as.numeric(E(my_graph)$weight)
color_palette <- colorRampPalette(c("yellow", "red"))(200)
normalized_weights <- (weight - min(weight)) / (max(weight) - min(weight))
edge_colors <- sapply(seq_along(normalized_weights), function(i) {
  if (i == 97) {
    "#009fff"
  } else {
    color_palette[as.integer(normalized_weights[i] * (length(color_palette) - 1)) + 1]
  }
})
edge_attr(my_graph)$color <- edge_colors

E(my_graph)$color <- edge_colors

plot(simplify(my_graph),
  layout = layout,
  vertex.size = (V(my_graph)$size) * 2,
  vertex.label.dist = 1,
  vertex.label.cex = 0.5,
  edge.width = E(my_graph)$width,
  edge.color = E(my_graph)$color,
  margin = 0.2,
  main = "Network based on the GLM ~ month",
  sub = "Stability threashold 0.90 - Verticles colored by families, Edges colored by weight",
  rescale = T
)
legend("left",
  legend = unique_families,
  col = unique_colors,
  pch = 19,
  title = "Families",
  pt.cex = 2,
  cex = 0.5,
  bty = "n",
  y.intersp = 0.6,
  inset = 1 / 10
)
```

```{r, cache=TRUE}
edgelist = as_edgelist(my_graph)

order_species <- c("Corynebacterium_3", "Corynebacterium_8",  "Fusobacterium_2", "Corynebacterium_3", "Corynebacterium_4", "Francisella_10", "Francisella_9", "Corynebacterium_6", "Mycobacterium_2", "Rhodococcus_1" , "Williamsia_1" , "Williamsia_2",  "Nocardioides_1" , "Sphingomonas_1", "Streptococcus_1", "Multi-affiliation_1", "Staphylococcus_3", "Staphylococcus_4","Staphylococcus_6" , "Peptoniphilus_1", "Candidatus Midichloria_2", "Candidatus Midichloria_6", "Candidatus Midichloria_7", "Candidatus Midichloria_3", "Rickettsia_3", "Candidatus Midichloria_4", "Candidatus Midichloria_5", "Rickettsia_1", "Rickettsia_11", "Rickettsia_2", "Rickettsia_6","Rickettsia_10", "Candidatus Midichloria_9","Rickettsia_7", "Rickettsia_7")


result <- result %>%  mutate(size = vertex_attr(my_graph)$size)
result_ordered <- result[match(order_species, result$Genus), ]

# Set the background color to black using par and text parameters
par(bg = "black", family = "serif", col.axis = "lightgrey", col.lab = "lightgrey", col.main = "lightgrey", col.sub = "lightgrey")
# plot arc diagram
arcplot(edgelist, 
        cex.labels = 0.7,
        sorted = FALSE,
        show.nodes = TRUE,
        bg.nodes = result_ordered$Color,
        cex.nodes = (result_ordered$size) * 0.8, 
        pch.nodes = 21, 
        lwd.nodes = 0.2, 
        line = 0,
        lwd.arcs = 20 * (edge_attr(my_graph)$weight),
        col.arcs = edge_attr(my_graph)$color,
        col.labels = "lightgrey", # Set font color for labels
        col.nodes = "black",  # Set font color for node labels
        bg = NA # Use NA to keep the par bg color
        #        above = c(1:97,99:114)
)
legend("topright",
       legend = unique_families,
       col = unique_colors,
       pch = 19,
       title = "Families",
       pt.cex = 2,
       cex = 0.7,
       text.font = 3, # Set font to Times New Roman (serif)
       text.col = "lightgrey", # Set font color to light grey
       bty = "n",
       y.intersp = 0.45,
       inset = c(-0.6, -0.02))
```

```{r, cache=TRUE}
my_graph_metaN <- c_net_update(my_graph)
V(my_graph_metaN)$v_group <- result$Family
V(my_graph_metaN)$color <- V(my_graph)$color
V(my_graph_metaN)$size <- vertex_attr(my_graph)$size
V(my_graph_metaN)$v_class <- result$Family
E(my_graph_metaN)$color <- E(my_graph)$color

# Set the background color to black using par and text parameters
par(bg = "white", family = "serif", col.axis = "lightgrey", col.lab = "lightgrey", col.main = "lightgrey", col.sub = "lightgrey")

c_net_plot(my_graph_metaN,
           vertex.color = V(my_graph_metaN)$color, 
           vertex.size = ((V(my_graph_metaN)$size)*1), 
           vertex.label.color = "black",
           vertex.label = V(my_graph_metaN)$name, 
           vertex.label.cex = 0.9,
           edge_width_range = c(0.5, 3), edge.color = "#AA0000", edge.curved = 0.4,
           legend = F, legend_number = F, 
           edge_legend_title = "Weight",
           size_legend = F, size_legend_title = "Abundance",
           width_legend = T, width_legend_title = "Weight", 
           main = "Female Network"
           )
# vertex_attr(my_graph_metaN)
# vertex_attr(my_graph)
legend("right",
  legend = unique_families,
  col = unique_colors,
  # title = "Families",
  pch = 19,
  pt.cex = 2,
  cex = 0.6,
  text.font = 3,
  bty = "n",
  y.intersp = 0.4,
  inset = 8 / 10
)
legend_x <- 0.85
legend_y <- 0.9 
text(x = legend_x - 2.5, y = legend_x - 0.35, labels = "Families", pos = 1, cex = 0.8, font = 4)
```











# Male Data Set
## PCA

```{r, cache=TRUE}
PLN_pca_M <- PLNPCA(
  formula = data_M$Abundance ~ 1 +
    offset(log(Offset)),
  data = data_M,
  ranks = 1:20
)

```

```{r, cache=TRUE}
plot(PLN_pca_M)
```

```{r, cache=TRUE}
PLN_pca_M_best <- getBestModel(PLN_pca_M, crit = "BIC")
```

```{r, cache=TRUE}
plot(PLN_pca_M_best, map = "individual", axes = 1:2, ind_cols = data_M$Ecological.gradient)
```

```{r, cache=TRUE}
sigma(PLN_pca_M_best) %>%
  corrplot::corrplot(is.corr = FALSE, tl.cex = 0.5, col = corrplot::COL2("PiYG"), type = "lower", diag = T)

# Define the threshold function
keep_high_correlations <- function(x) {
  any(x > 2 | x < -1)
}

########################### Climatic ##################
rows_to_keep <- apply(sigma(PLN_pca_M_best), 1, keep_high_correlations)
cols_to_keep <- apply(sigma(PLN_pca_M_best), 2, keep_high_correlations)

# Subset the matrix to keep only the selected rows and columns
PLN_pca_M_best_filtered <- sigma(PLN_pca_M_best)[rows_to_keep, cols_to_keep]

# Print the head of the filtered matrix to check
# head(oaks_best_pca_filtered)
PLN_pca_M_best_filtered %>%
  corrplot::corrplot(is.corr = FALSE, tl.cex = 0.4, col = corrplot::COL2("PiYG"), type = "lower", diag = T)
```

```{r, cache=TRUE}
factoextra::fviz_pca_biplot(PLN_pca_M_best,
                            select.var = list(contrib = 10),
                            labels = NULL,
                            geom = "point"
) # CONTRIBUTION TOP 20 CLUSTER.
```

```{r, cache=TRUE}
# Define your color palette
colors <- c(
  "wild" = "#009392",
  "ecotone" = "#9ccb86",
  "farmed land" = "#EEB479",
  "urban" = "#CF597E"
)

# Plot PCA with ordered legend
fviz_pca_ind(PLN_pca_M_best,
             col.ind = data_M$Ecological.gradient,
             palette = colors,
             geom.ind = "point",
             repel = TRUE,
             pointsize = 4,
             pointshape = 19,
             col.var = "black",
             arrowsize = 0.6,
             labelsize = 4
) +
  labs(color = "Ecological gradient") +
  scale_color_manual(values = colors) +
  guides(color = guide_legend(order = 1))
```

```{r, cache=TRUE}
fviz_pca_var(PLN_pca_M_best,
             col.var = "contrib",
             gradient.cols = c("#00AFBB",
                               "#E7B800",
                               "#FC4E07"),
             select.var = list(contrib = 20)
)
```

```{r, cache=TRUE}
PLN_pca_M_best$var %>%
  as.data.frame() %>%
  select(contrib.Dim.1, contrib.Dim.2) %>%
  arrange(contrib.Dim.1) %>%
  tail(n = 10) %>%
  knitr::kable()
```

```{r, cache=TRUE}
fviz_contrib(PLN_pca_M_best, choice = "var", axes = 1:2, top = 10)
```

## Network

### Modeling

```{r, cache=F}
networks_M <- PLNnetwork(formula = data_M$Abundance ~ 1 +
                           Ecological.gradient  +
                           offset(log(Offset)), data = data_M)

```

```{r, cache=TRUE}
plot(networks_M, "diagnostic")
```

```{r, cache=TRUE}
coefficient_path(networks_M, corr = TRUE) %>%
  ggplot(aes(x = Penalty, y = Coeff, group = Edge, colour = Edge)) +
  geom_line(show.legend = FALSE) +
  coord_trans(x = "log10") +
  theme_bw()
```

```{r, cache=TRUE}
model_StARS <- getBestModel(networks_M, "StARS")
```

```{r, cache=TRUE}
plot(networks_M, "stability")
```

```{r, cache=TRUE, warning=FALSE, eval=FALSE}
data.frame(
  fitted   = as.vector(fitted(model_StARS)),
  observed = as.vector(count_f2)
) %>%
  ggplot(aes(x = observed, y = fitted)) +
  geom_point(size = .5, alpha = .25) +
  scale_x_log10(limits = c(1, 4000)) +
  scale_y_log10(limits = c(1, 4000)) +
  theme_bw() +
  annotation_logticks()
```

## Visualisation

```{r, cache=T}

networks_M_2 <- getBestModel(networks_M, crit = "StARS", stability = 0.9)

my_graph <- plot(networks_M_2, plot = F)
Isolated <- which(igraph::degree(my_graph) == 0)
my_graph_cleaned <- igraph::delete_vertices(my_graph, Isolated)
# my_graph_cleaned <- delete_vertices(my_graph, c("Francisella_8", "Candidatus Midichloria_11"))

my_graph <- my_graph_cleaned

vertices_names <- V(my_graph)$name
taxo <- tax_table(physeq)

result <- merged_metagenomes@tax_table %>% 
  as.data.frame() %>%
  filter(Genus %in% vertices_names) %>%
  select(Genus, Family)

# Extract unique families
unique_families <- unique(result$Family)
# Generate distinct colors for each family
n_colors <- length(unique_families)
colors <- khroma::colour("smooth rainbow")(n_colors)
# Create a named vector to map each family to a color
family_colors <- setNames(colors, unique_families)
# Add the color information to the result dataframe
result <- result %>%
  mutate(Color = family_colors[Family])

# extract abundance OTU
otu_table_df <- as.data.frame(otu_table(physeq))
abundance <- otu_table_df %>%
  mutate(Abundance = rowSums(.)) %>%
  rownames_to_column("vertices_left")
abundance_solo <- abundance %>%
  as.data.frame() %>%
  filter(vertices_left %in% vertices_names) %>%
  select(Abundance)

# # Convert the Abundance column to a numeric vector
# vertex_sizes <- as.numeric(abundance_solo$Abundance)
# # Scale the vertex sizes for better visibility
# vertex_sizes <- (vertex_sizes / max(vertex_sizes)) * 10  # Adjust the multiplier as needed
# Assign colors to the vertices
V(my_graph)$color <- result$Color
# Assign sizes to the vertices
# V(my_graph)$size <- vertex_sizes
# Choose a layout that spreads out the vertices
layout <- igraph::layout_in_circle(my_graph)

# Define unique colors and families for the legend
unique_colors <- unique(result$Color)
unique_families <- unique(result$Family)

# Define edge width for the legend
edge_widths <- E(my_graph)$width
unique_edge_widths <- unique(edge_widths)

# Edge - Arc colors
weight <- as.numeric(E(my_graph)$weight)
color_palette <- colorRampPalette(c("yellow", "red"))(200)
normalized_weights <- (weight - min(weight)) / (max(weight) - min(weight))
edge_colors <- sapply(seq_along(normalized_weights), function(i) {
  if (i == 97) {
    "#009fff"
  } else {
    color_palette[as.integer(normalized_weights[i] * (length(color_palette) - 1)) + 1]
  }
})
edge_attr(my_graph)$color <- edge_colors

E(my_graph)$color <- edge_colors

plot(simplify(my_graph),
     layout = layout,
     vertex.size = (V(my_graph)$size) * 2,
     vertex.label.dist = 1,
     vertex.label.cex = 0.5,
     edge.width = E(my_graph)$width,
     edge.color = E(my_graph)$color,
     margin = 0.2,
     main = "Network based on the GLM ~ month",
     sub = "Stability threashold 0.90 - Verticles colored by families, Edges colored by weight",
     rescale = T
)
legend("left",
       legend = unique_families,
       col = unique_colors,
       pch = 19,
       title = "Families",
       pt.cex = 2,
       cex = 0.5,
       bty = "n",
       y.intersp = 0.6,
       inset = 1 / 10
)
```

```{r, cache=TRUE}
edgelist = as_edgelist(my_graph)

order_species <- c("Corynebacterium_3", "Corynebacterium_8",  "Fusobacterium_2", "Corynebacterium_3", "Corynebacterium_4", "Francisella_10", "Francisella_9", "Corynebacterium_6", "Mycobacterium_2", "Rhodococcus_1" , "Williamsia_1" , "Williamsia_2",  "Nocardioides_1" , "Sphingomonas_1", "Streptococcus_1", "Multi-affiliation_1", "Staphylococcus_3", "Staphylococcus_4","Staphylococcus_6" , "Peptoniphilus_1", "Candidatus Midichloria_2", "Candidatus Midichloria_6", "Candidatus Midichloria_7", "Candidatus Midichloria_3", "Rickettsia_3", "Candidatus Midichloria_4", "Candidatus Midichloria_5", "Rickettsia_1", "Rickettsia_11", "Rickettsia_2", "Rickettsia_6","Rickettsia_10", "Candidatus Midichloria_9","Rickettsia_7", "Rickettsia_7")


result <- result %>%  mutate(size = vertex_attr(my_graph)$size)
result_ordered <- result[match(order_species, result$Genus), ]

# Set the background color to black using par and text parameters
par(bg = "black", family = "serif", col.axis = "lightgrey", col.lab = "lightgrey", col.main = "lightgrey", col.sub = "lightgrey")
# plot arc diagram
arcplot(edgelist, 
        cex.labels = 0.7,
        sorted = FALSE,
        show.nodes = TRUE,
        bg.nodes = result_ordered$Color,
        cex.nodes = (result_ordered$size) * 0.8, 
        pch.nodes = 21, 
        lwd.nodes = 0.2, 
        line = 0,
        lwd.arcs = 20 * (edge_attr(my_graph)$weight),
        col.arcs = edge_attr(my_graph)$color,
        col.labels = "lightgrey", # Set font color for labels
        col.nodes = "black",  # Set font color for node labels
        bg = NA # Use NA to keep the par bg color
        #        above = c(1:97,99:114)
)
legend("topright",
       legend = unique_families,
       col = unique_colors,
       pch = 19,
       title = "Families",
       pt.cex = 2,
       cex = 0.7,
       text.font = 3, # Set font to Times New Roman (serif)
       text.col = "lightgrey", # Set font color to light grey
       bty = "n",
       y.intersp = 0.45,
       inset = c(-0.6, -0.02))
```

```{r, cache=TRUE}
my_graph_metaN <- c_net_update(my_graph)
V(my_graph_metaN)$v_group <- result$Family
V(my_graph_metaN)$color <- V(my_graph)$color
V(my_graph_metaN)$size <- vertex_attr(my_graph)$size
V(my_graph_metaN)$v_class <- result$Family
E(my_graph_metaN)$color <- E(my_graph)$color

# Set the background color to black using par and text parameters
par(bg = "white", family = "serif", col.axis = "lightgrey", col.lab = "lightgrey", col.main = "lightgrey", col.sub = "lightgrey")

c_net_plot(my_graph_metaN,
           vertex.color = V(my_graph_metaN)$color, 
           vertex.size = ((V(my_graph_metaN)$size)*1), 
           vertex.label.color = "black",
           vertex.label = V(my_graph_metaN)$name, 
           vertex.label.cex = 0.9,
           edge_width_range = c(0.5, 3), edge.color = "#AA0000", edge.curved = 0.4,
           legend = F, legend_number = F, 
           edge_legend_title = "Weight",
           size_legend = F, size_legend_title = "Abundance",
           width_legend = T, width_legend_title = "Weight", 
           main = "Male Network"
)
# vertex_attr(my_graph_metaN)
# vertex_attr(my_graph)
legend("right",
       legend = unique_families,
       col = unique_colors,
       # title = "Families",
       pch = 19,
       pt.cex = 2,
       cex = 0.6,
       text.font = 3,
       bty = "n",
       y.intersp = 0.4,
       inset = 8 / 10
)
legend_x <- 0.85
legend_y <- 0.9 
text(x = legend_x - 2.5, y = legend_x - 0.35, labels = "Families", pos = 1, cex = 0.8, font = 4)
```


```{r}
future::plan("sequential")
```
